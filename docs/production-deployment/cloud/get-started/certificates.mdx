---
id: certificates
title: Manage certificates
sidebar_label: Manage certificates
description: Temporal Cloud supports mTLS authentication with CA certificates. Keep certificates updated to avoid service disruptions.
slug: /cloud/certificates
toc_max_heading_level: 4
keywords:
  - certificates
  - temporal cloud
  - mtls
tags:
  - Security
  - Certificates
---

[Temporal Cloud](https://temporal.io/cloud) supports both mTLS and [API key](/cloud/api-keys) authentication for namespace access.

:::caution Don't let your certificates expire

An expired root CA certificate invalidates all downstream certificates and prevents clients from connecting to your Namespace.

Temporal Cloud sends courtesy emails to Global and Namespace Admins 15, 10, and 5 days before certificate expiry.

To update certificates, see [Manage certificates](#manage-certificates).

:::

## Certificate requirements {#certificate-requirements}

### CA certificates

CA certificates must meet these criteria:

- X.509v3 format
- Each certificate must be a root or issued by another certificate in the bundle
- Must include `CA: true`
- Cannot be a well-known CA (like DigiCert or Let's Encrypt) unless certificate filters are specified
- Signing algorithm must be RSA or ECDSA with SHA-256 or stronger (no SHA-1 or MD5)
- Cannot be generated with a passphrase

:::info

A certificate bundle can contain up to 16 CA certificates with a maximum payload size of 32 KB before base64 encoding.

:::

### End-entity certificates

End-entity (leaf) certificates must meet these criteria:

- X.509v3 format
- Basic constraints must include `CA: false`
- Key usage must include Digital Signature
- Signing algorithm must be RSA or ECDSA with SHA-256 or stronger (no SHA-1 or MD5)
- Each certificate in the chain must have a unique Distinguished Name (not case-sensitive)

## Issue certificates {#issue-certificates}

Choose the option that fits your setup:

### Option 1: Existing certificate infrastructure

If you already have certificate management infrastructure:

1. Export your CA certificate and generate end-entity certificates using your existing tools
2. Ensure the CA certificate is long-lived and end-entity certificates expire before the CA
3. [Upload the CA certificate](#manage-certificates) and [configure your clients](#configure-clients-to-use-client-certificates)

### Option 2: No certificate infrastructure

**We recommend using API keys for authentication** if you don't have existing certificate management infrastructure. API keys are easier to manage than mTLS certificates.

If you still want to use mTLS, generate certificates using:

#### Using tcld

Generate a CA certificate (max 1-year duration):

```sh
mkdir temporal-certs && cd temporal-certs
tcld gen ca --org temporal -d 1y --ca-cert ca.pem --ca-key ca.key
```

Generate an end-entity certificate (must expire before CA):

```sh
tcld gen leaf --org temporal -d 364d --ca-cert ca.pem --ca-key ca.key --cert client.pem --key client.key
```

#### Using certstrap

1. Create a Certificate Authority:
   ```sh
   ./certstrap init --common-name "CertAuth"
   ```

2. Set your namespace name:
   ```sh
   export NAMESPACE_NAME=your-namespace
   ```

3. Request and sign an end-entity certificate:
   ```sh
   ./certstrap request-cert --common-name ${NAMESPACE_NAME}
   ./certstrap sign ${NAMESPACE_NAME} --CA "CertAuth"
   ```

4. (Optional) Convert to PKCS8 for Java SDK:
   ```sh
   openssl pkcs8 -topk8 -inform PEM -outform PEM -in out/${NAMESPACE_NAME}.key -out out/${NAMESPACE_NAME}.pkcs8.key -nocrypt
   ```

## Control authorization {#control-authorization}

Scope end-entity certificates to specific Namespaces using one of these methods:

**Option 1:** Issue a separate root certificate for each Namespace

**Option 2:** Use the same root certificate for all Namespaces but create separate [certificate filters](#manage-certificate-filters) for each

## Manage certificates {#manage-certificates}

:::note

Requires [Namespace Admin](/cloud/users#namespace-level-permissions) permission.

:::

Follow this zero-downtime rotation process:

### Using Temporal Cloud UI

1. Navigate to **Namespaces** and select your Namespace
2. Click **Edit** → **Authentication** card
3. Paste the new certificate after the existing one (both certificates will be active)
4. Click **Save**
5. Wait until all Workers use the new certificate
6. Return to **Edit** → **Authentication** and remove the old certificate
7. Click **Save**

### Using tcld

1. Create a file with both old and new CA certificates:
   ```
   -----BEGIN CERTIFICATE-----
   ... old CA cert ...
   -----END CERTIFICATE-----
   -----BEGIN CERTIFICATE-----
   ... new CA cert ...
   -----END CERTIFICATE-----
   ```

2. Update the Namespace:
   ```bash
   tcld namespace accepted-client-ca set --ca-certificate-file <path>
   ```

3. Monitor traffic until the old certificate is no longer in use

4. Create a file with only the new certificate and run the command again

## Handle compromised certificates

:::warning

Temporal does not support certificate revocation lists (CRLs). Keep certificates up to date.

:::

**Recommended approach:** Use short-lived end-entity certificates that can expire naturally.

If immediate action is required:

1. Generate a new CA certificate
2. Deploy the new CA alongside the existing one
3. Regenerate and deploy end-entity certificates with the new CA
4. Test connectivity with the new certificates
5. Remove the compromised CA certificate
6. Monitor audit logs and review security practices

If using certificate filters, you can block compromised certificates by updating the filters.

## Certificate filters {#manage-certificate-filters}

Limit access to specific end-entity certificates by creating filters with these fields:

- commonName (CN)
- organization (O)
- organizationalUnit (OU)
- subjectAlternativeName (SAN)

**Rules:**
- Values are case-insensitive
- All specified values must match exactly (unless using wildcards)
- Use single `*` wildcard at the beginning or end of a value (not both)
- Maximum 25 filters per Namespace

**Examples:**

```json
// Match exact CN
{
  "CN": "code.example.com"
}

// Match CN and O
{
  "CN": "stage.example.com",
  "O": "Example Code Inc."
}

// Valid wildcards
"*.example.com"     // matches code.example.com
"Example Code*"     // matches Example Code Inc.

// Invalid wildcards
".example.*"
"code.*.com"
"*"
```

### Manage filters using UI

1. Navigate to **Namespaces** → select Namespace → **Edit**
2. Click **Certificate Filters**
3. Add or remove filters as needed
4. Click **Save**

### Manage filters using tcld

- Set filters: `tcld namespace certificate-filters import`
- Clear filters: `tcld namespace certificate-filters clear`
- View filters: `tcld namespace certificate-filters export`

## Configure clients {#configure-clients-to-use-client-certificates}

Configure your SDK to use client certificates:

- [Go SDK](/develop/go/temporal-client#connect-to-temporal-cloud)
- [Java SDK](/develop/java/temporal-client#connect-to-temporal-cloud)
- [PHP SDK](/develop/php/temporal-client#connect-to-a-dev-cluster)
- [Python SDK](/develop/python/temporal-client#connect-to-temporal-cloud)
- [TypeScript SDK](/develop/typescript/temporal-client#connect-to-temporal-cloud)
- [.NET SDK](/develop/dotnet/temporal-client#connect-to-temporal-cloud)

### Temporal CLI

```sh
temporal <command> <subcommand> \
    --tls-ca-path <Path to server CA certificate> \
    --tls-cert-path <Path to x509 certificate> \
    --tls-key-path <Path to private certificate key> \
    --tls-server-name <Override for target TLS server name>
```

For more information, see [CLI environment variables](/cli#environment-variables).